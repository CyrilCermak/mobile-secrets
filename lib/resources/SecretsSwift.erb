//
//  Autogenerated file by Mobile Secrets
//

<% if should_decrypt_files %>import CommonCrypto<% end %>
import Foundation

class Secrets {
    static let standard = Secrets()
    private let bytes: [[UInt8]] = <%= secrets_array.to_s.gsub "],", "],\n                                   "%>
<% if should_decrypt_files %>
    private let fileNames: [[UInt8]] = <%= file_names_array.to_s.gsub "],", "],\n                                       "%>
<% end %>

    private init() {}

    func string(forKey key: String, password: String? = nil) -> String? {
        let pwdBytes = password == nil ? bytes[0] : password?.map({ c in c.asciiValue ?? 0 })
        guard let index = bytes.firstIndex(where: { String(data: Data($0), encoding: .utf8) == key }),
            let pwd = pwdBytes,
            let value = decrypt(bytes[index + 1], password: pwd) else { return nil }

        return String(data: Data(value), encoding: .utf8)
    }

    private func decrypt(_ input: [UInt8], password: [UInt8]) -> [UInt8]? {
        guard !password.isEmpty else { return nil }
        var output = [UInt8]()
        for byte in input.enumerated() {
            output.append(byte.element ^ password[byte.offset % password.count])
        }
        return output
    }

<% if should_decrypt_files %>
    func decryptFiles(bundle: Bundle = Bundle.main, password: String? = nil) throws {
        try fileNames.forEach({ (fileNameBytes) in
            guard let name = String(data: Data(fileNameBytes), encoding: .utf8) else {
                fatalError("Wrong name in file names")
            }

            try decryptFile(name, bundle: bundle, password: password)
        })
    }

    func decryptFile(_ fileName: String, bundle: Bundle = Bundle.main, password: String? = nil) throws {
        let password = password == nil ? String(data: Data(bytes[0]), encoding: .utf8) : password

        guard let pwd = password else {
            fatalError("No password for decryption was provided!")
        }

        guard let filePath = bundle.path(forResource: fileName, ofType: "enc"),
            let fileURL = URL(string: "file://" + filePath),
            let fileData = try? Data(contentsOf: fileURL) else {
                fatalError("File \(fileName) was not found in bundle!")
        }

        var outputURL = bundle.bundleURL
        outputURL.appendPathComponent(fileName)

        do {
            let aes = try AES(keyString: pwd)
            let decryptedString = try aes.decrypt(fileData)
            try decryptedString.write(to: outputURL, atomically: true, encoding: .utf8)
        } catch let e {
            throw e
        }
    }

    struct AES {
        enum Error: Swift.Error {
            case invalidKeySize
            case encryptionFailed
            case decryptionFailed
            case dataToStringFailed
        }

        private var key: Data
        private var ivSize: Int = kCCBlockSizeAES128
        private let options: CCOptions  = CCOptions()

        init(keyString: String) throws {
            guard keyString.count == kCCKeySizeAES256 else {
                throw Error.invalidKeySize
            }
            self.key = Data(keyString.utf8)
        }

        func decrypt(_ data: Data) throws -> String {
            let bufferSize: Int = data.count - ivSize
            var buffer = Data(count: bufferSize)
            var numberBytesDecrypted: Int = 0

            do {
                try key.withUnsafeBytes { keyBytes in
                    try data.withUnsafeBytes { dataToDecryptBytes in
                        try buffer.withUnsafeMutableBytes { bufferBytes in

                            guard let keyBytesBaseAddress = keyBytes.baseAddress,
                                let dataToDecryptBytesBaseAddress = dataToDecryptBytes.baseAddress,
                                let bufferBytesBaseAddress = bufferBytes.baseAddress else {
                                    throw Error.encryptionFailed
                            }

                            let cryptStatus: CCCryptorStatus = CCCrypt( // Stateless, one-shot encrypt operation
                                CCOperation(kCCDecrypt),                // op: CCOperation
                                CCAlgorithm(kCCAlgorithmAES),        // alg: CCAlgorithm
                                options,                                // options: CCOptions
                                keyBytesBaseAddress,                    // key: the "password"
                                key.count,                              // keyLength: the "password" size
                                dataToDecryptBytesBaseAddress,          // iv: Initialization Vector
                                dataToDecryptBytesBaseAddress + ivSize, // dataIn: Data to decrypt bytes
                                bufferSize,                             // dataInLength: Data to decrypt size
                                bufferBytesBaseAddress,                 // dataOut: decrypted Data buffer
                                bufferSize,                             // dataOutAvailable: decrypted Data buffer size
                                &numberBytesDecrypted                   // dataOutMoved: the number of bytes written
                            )

                            guard cryptStatus == CCCryptorStatus(kCCSuccess) else {
                                throw Error.decryptionFailed
                            }
                        }
                    }
                }
            } catch {
                throw Error.encryptionFailed
            }

            let decryptedData: Data = buffer[..<numberBytesDecrypted]
            guard let decryptedString = String(data: decryptedData, encoding: .utf8) else {
                throw Error.dataToStringFailed
            }

            return decryptedString
        }
  }
<% end %>
}
